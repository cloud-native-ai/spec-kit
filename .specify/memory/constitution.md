<!--
IMPORTANT: This file is part of the spec-kit project's own usage of the spec-kit framework.
The .specify/ directory contains files generated by spec-kit for the spec-kit project itself.
The rest of the repository (src/, templates/, scripts/, etc.) contains the generic spec-kit source code that can be used by other projects.

Key distinction:
- .specify/ directory: Project-specific files for spec-kit project (this project)
- All other directories: Generic spec-kit source code (reusable by other projects)

This constitution.md file represents the constitution for the spec-kit project itself,
not a template for other projects. Other projects should use the template in 
memory/constitution.md (in the root of the spec-kit repository) as their starting point.
-->

<!-- 
Sync Impact Report:
- Version change: template → 1.0.0
- Added all core principles from SDD methodology
- Added security, performance, and workflow sections
- Templates requiring updates: ✅ All templates align with new constitution
- Follow-up TODOs: None - all placeholders replaced with concrete principles
-->

# Spec Kit Constitution

## Core Principles

### I. Library-First Principle
Every feature in Spec Kit MUST begin its existence as a standalone library. No feature shall be implemented directly within application code without first being abstracted into a reusable library component. Libraries must be self-contained, independently testable, and well-documented. Each library must have a clear, singular purpose—no organizational-only or wrapper libraries are permitted.

### II. CLI Interface Mandate
Every library MUST expose its functionality through a command-line interface. All CLI interfaces MUST: accept text as input (via stdin, arguments, or files), produce text as output (via stdout), send errors and warnings to stderr, and support both human-readable and JSON formats for structured data exchange. This ensures observability, testability, and integration capability.

### III. Test-First Imperative (NON-NEGOTIABLE)
This is NON-NEGOTIABLE: All implementation MUST follow strict Test-Driven Development. No implementation code shall be written before: (1) Unit tests are written, (2) Tests are validated and approved by the user, (3) Tests are confirmed to FAIL (Red phase). Only then can implementation proceed to make tests pass (Green phase), followed by refactoring (Refactor phase). This Red-Green-Refactor cycle is strictly enforced.

### IV. Integration Testing Requirements
Integration tests are mandatory for: new library contract tests, contract changes, inter-service communication, shared schemas, and any functionality that interacts with external systems. Tests MUST use realistic environments: prefer real databases over mocks, use actual service instances over stubs, and validate end-to-end workflows. Contract tests must be written and validated before implementation begins.

### V. Observability, Versioning & Simplicity
Text I/O ensures debuggability and structured logging is required for all operations. Versioning follows MAJOR.MINOR.PATCH semantic versioning: MAJOR for backward incompatible changes, MINOR for new features, PATCH for bug fixes. Start simple and apply YAGNI principles—no future-proofing or speculative features. Complexity must be explicitly justified and documented.

## Security Requirements

All code MUST follow secure coding practices. Input validation is required for all external inputs. Dependencies must be regularly audited for vulnerabilities. Sensitive data must be handled according to security best practices. All network communications must use secure protocols (TLS/SSL). Security considerations must be documented in implementation plans.

## Performance Standards

All implementations must meet defined performance requirements. Performance testing is required for features with explicit performance criteria. Optimizations should be data-driven and validated through benchmarking. Resource usage (CPU, memory, network) must be monitored and documented. Performance degradation must be prevented through regression testing.

## Development Workflow

All development follows the Spec-Driven Development (SDD) workflow: constitution → specification → plan → tasks → implementation → validation. Code reviews must verify compliance with constitutional principles. All changes must be made through feature branches with descriptive names. Pull requests must include comprehensive test coverage and documentation updates. Automated quality gates must pass before merging.

## Governance

This constitution supersedes all other development practices and guidelines. All pull requests and code reviews MUST verify compliance with these principles. Amendments to this constitution require: explicit documentation of the rationale for change, review and approval by project maintainers, and a backwards compatibility assessment. Complexity must be justified against the simplicity principle. Use the SDD methodology and templates for runtime development guidance.

**Version**: 1.0.0 | **Ratified**: 2025-11-17 | **Last Amended**: 2025-11-17